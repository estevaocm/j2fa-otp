package j2fa.otp;

import org.apache.commons.codec.binary.Base32;

public class OTPAuth {
	
	private String type = "totp";
	private String issuer;
	private String account;
	private String secretHex; 
	private String secretBase32; 
	private String algo;
	private Integer digits;
	private Integer period;
	
	public OTPAuth(String issuer, String account, String secret, 
			String algo, Integer digits, Integer period) {
		if(issuer == null || issuer.isEmpty()) {
			throw new IllegalArgumentException("issuer");
		}
		if(account == null || account.isEmpty()) {
			throw new IllegalArgumentException("account");
		}
		if(secret == null || secret.isEmpty()) {
			throw new IllegalArgumentException("secret");
		}
		
		this.issuer = issuer;
		this.account = account;
		this.secretHex = secret;
		this.algo = algo;
		this.digits = digits;
		this.period = period;
		this.secretBase32 = new Base32().encodeAsString(DataUtils.hexToBytes(secret));
	}
	
	public OTPAuth(String issuer, String account, byte[] secret, 
			String algo, Integer digits, Integer period) {
		this(issuer, account, DataUtils.bytesToHex(secret), algo, digits, period);
	}
	
	public String setupPath() {
		//secret must be base32
	    //https://github.com/google/google-authenticator/wiki/Key-Uri-Format
		String path = "otpauth://" + this.type + "/" + this.issuer + ":" + this.account 
				+ "?secret=" + this.secretBase32 + "&issuer=" + this.issuer;
		if(this.algo != null && !this.algo.isEmpty()) {//default: SHA1
			path += "&algorithm=" + this.algo;
		}
		if(this.digits != null) {//default: 6
			path += "&digits=" + this.digits;
		}
		if(this.period != null) {//default: 30
			path += "&period=" + this.period;
		}
	    return path;
	}
	
	public String generate() {
		long unixTime = System.currentTimeMillis()/(1000L * this.period);
		//System.out.println(unixTime);
		String step = "0000000000000000" + Long.toHexString(unixTime).toUpperCase();
		step = step.substring(step.length() -16);
		String digits = "6";
		if(this.digits != null) {
			digits = this.digits.toString();
		}
		return TimebasedOneTimePassword.generate(this.secretHex, step, digits);
	}
}
